
Gramática:
P → SP | CtrlP | S | Ctrl
S →  var_pos ; | funcion; | var_asign;
Ctrl →  IFE | Loop

Loop → while(exp_bool) Bloque | do Bloque while(exp_bool); | for(var_asig; exp_bool; var_pos)Bloque

Control:
IFE→ if(exp_bool) then Bloque else Bloque
Bloque → S | {P}


Funciones
Func → FuncReturn | FuncVoid
FuncReturn → FuncInt | colineales(exp_bool,exp_bool) | capitalizar(exp_cadena)
FuncInt → multiplicacionEscalar(Vec, exp_mat, var) | length(var)
FuncVoid → print(valores) 

Vectores  y variables
Valores → exp_mat | exp_bool | exp_cadena | VARIABLE|  VARIABLE[NUMBER]  | var_pos


Operaciones binarias enteros:
exp_mat → exp_mat + F | exp_mat - F | F
F → P * Exp | F / Exp | F % Exp | Exp
Exp → Exp ^ ISing | ISing
ISing → -Paren | +Paren | Paren
Paren → (exp_mat) | Valores | FuncInt

Operaciones con strings
exp_cadena → exp_cadena + CADENA | exp_cadena + capitalizar(exp_cadena) | CADENA| capitalizar(exp_cadena) 

Registros:
Reg → {U}
U -> CADENA: Valores, U | CADENA: Valores


Operadores de variables:
var_pos → --SMM | ++SMM | SMM
SMM → exp_mat++ | exp_mat--

 Asignaciones:
var_asig → SIgual *= Valores | SIgual /= Valores | SIgual
SIgual → Asig += Valores |  Asig -= Valores | Asig
Asig → VARIABLE = Valores  | VARIABLE  = [valores_list] 
lista_valores -> Valores,lista_valores| Valores

// (para generar a = b += 1)
//a = v *= [1,2,3] ? 

exp_bool -> True | False

Lo de abajo no esta implementado
Op booleanas
exp_bool → Or ? exp_bool : exp_bool  | Or
Or → Or or And | And
And →  And and Eq | Eq
Eq → Eq == TBool |  Eq != TBool | Mayor 
Mayor → TCompare > TCompare | TCompare >= TCompare | Menor
Menor → TCompare < TCompare | TCompare <= TCompare | Not 
// (not 1 < 2 != not (1 < 2))
Not →  not Not | TBool 
TBool → (exp_bool) | bool | VarYVals | FuncBool
TCompare → exp_mat | var_pos | VarYVals | FuncInt
